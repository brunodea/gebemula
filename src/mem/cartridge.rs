// Generated by bitflags
#![allow(if_not_else)]

use mem::mem::Memory;
use mem::consts;
use std::str;

#[derive(Copy, Clone, Eq, PartialEq, Debug)]
pub enum MapperType {
    Rom,

    // Standard mappers
    Mbc1,
    Mbc2,
    Mbc3,
    Mbc5,
    Mbc6,
    Mbc7,
    Mmm01,

    // Non-standard mappers & hardware
    Huc1,
    Huc3,
    Tama5,
    PocketCamera,

    Unknown,
}

bitflags! {
    pub flags CartExtraHardware : u32 {
        const NONE_HW       = 0,
        const RAM           = 1 << 0,
        const BATTERY       = 1 << 1,
        const RTC           = 1 << 2,
        const RUMBLE        = 1 << 3,
        const ACCELEROMETER = 1 << 4,
    }
}

pub fn cartridge_type_string(mapper: MapperType, extra_hw: CartExtraHardware) -> String {
    let mut s = match mapper {
        MapperType::Rom  => "ROM",

        MapperType::Mbc1 => "MBC1",
        MapperType::Mbc2 => "MBC2",
        MapperType::Mbc3 => "MBC3",
        MapperType::Mbc5 => "MBC5",
        MapperType::Mbc6 => "MBC6",
        MapperType::Mbc7 => "MBC7",
        MapperType::Mmm01 => "MMM01",

        MapperType::Huc1 => "HuC1",
        MapperType::Huc3 => "HuC3",
        MapperType::Tama5 => "TAMA5",
        MapperType::PocketCamera => "Pocket Camera",

        MapperType::Unknown => "???",
    }.to_owned();

    if extra_hw.contains(RAM) {
        s.push_str("+RAM");
    }
    if extra_hw.contains(BATTERY) {
        s.push_str("+BATTERY");
    }
    if extra_hw.contains(RTC) {
        s.push_str("+RTC");
    }
    if extra_hw.contains(RUMBLE) {
        s.push_str("+RUMBLE");
    }

    s
}

pub fn cart_type_from_id(id: u8) -> (MapperType, CartExtraHardware) {
    match id {
        0x00 => (MapperType::Rom, NONE_HW),
        0x01 => (MapperType::Mbc1, NONE_HW),
        0x02 => (MapperType::Mbc1, RAM),
        0x03 => (MapperType::Mbc1, RAM | BATTERY),

        0x05 => (MapperType::Mbc2, NONE_HW),
        0x06 => (MapperType::Mbc2, RAM | BATTERY),

        0x08 => (MapperType::Rom, RAM),
        0x09 => (MapperType::Rom, RAM | BATTERY),

        0x0B => (MapperType::Mmm01, NONE_HW),
        0x0C => (MapperType::Mmm01, RAM),
        0x0D => (MapperType::Mmm01, RAM | BATTERY),

        0x0F => (MapperType::Mbc3, RTC | BATTERY),
        0x10 => (MapperType::Mbc3, RAM | RTC | BATTERY),
        0x11 => (MapperType::Mbc3, NONE_HW),
        0x12 => (MapperType::Mbc3, RAM),
        0x13 => (MapperType::Mbc3, RAM | BATTERY),

        0x19 => (MapperType::Mbc5, NONE_HW),
        0x1A => (MapperType::Mbc5, RAM),
        0x1B => (MapperType::Mbc5, RAM | BATTERY),
        0x1C => (MapperType::Mbc5, RUMBLE),
        0x1D => (MapperType::Mbc5, RAM | RUMBLE),
        0x1E => (MapperType::Mbc5, RAM | BATTERY | RUMBLE),

        0x20 => (MapperType::Mbc6, RAM | BATTERY),

        0x22 => (MapperType::Mbc7, RAM | BATTERY | ACCELEROMETER),

        0xFC => (MapperType::PocketCamera, NONE_HW),
        0xFD => (MapperType::Tama5, NONE_HW),
        0xFE => (MapperType::Huc3, NONE_HW),
        0xFF => (MapperType::Huc1, RAM | BATTERY),

        _    => (MapperType::Unknown, NONE_HW)
    }
}

pub fn game_title_str(memory: &Memory) -> String {
    let game_title_u8: &mut Vec<u8> = &mut Vec::new();
    for byte in consts::GAME_TITLE_ADDR_START..(consts::GAME_TITLE_ADDR_END + 1) {
        if byte == 0 {
            break;
        }
        game_title_u8.push(memory.read_byte(byte));
    }
    let game_title: &str = match str::from_utf8(&game_title_u8) {
        Ok(v) => v,
        Err(_) => "Undefined",
    };

    game_title.to_owned()
}
